SPLTheory : THEORY
BEGIN

  Product : TYPE+
  emptyproduct : Product
  nonemptyproduct?(p:Product) : bool = p /= emptyproduct

  Property: TYPE+
  emptyproperty : Property
  nonemptyproperty?(p:Property) : bool = p /= emptyproperty

  alpha: [Product -> Property]

  PresenceCondition: TYPE+
  truepc : PresenceCondition
  Conf: TYPE = set[PresenceCondition]

  AnnotativeModel : DATATYPE
  BEGIN
     ModelBase(m:Product): ModelBase?
     ModelChoice(pc:PresenceCondition, vm1:AnnotativeModel, vm2:AnnotativeModel): ModelChoice?
  END AnnotativeModel

  pi(vm:AnnotativeModel,c:Conf): RECURSIVE Product =
    CASES vm OF
      ModelBase(m): m,
      ModelChoice(pc, vm1, vm2):
        IF c(pc) THEN
	   pi(vm1,c)
	ELSE
	   pi(vm2,c)
	ENDIF
    ENDCASES
    MEASURE vm by <<

  AnnotativeExpression : DATATYPE
  BEGIN
     BaseExpression(p:Property): BaseExpression?
     ChoiceExpression(pc:PresenceCondition, vp1:AnnotativeExpression, vp2:AnnotativeExpression): ChoiceExpression?
  END AnnotativeExpression  

  sigma(vp:AnnotativeExpression,c:Conf): RECURSIVE Property =
    CASES vp OF
      BaseExpression(p): p,
      ChoiceExpression(pc, vp1, vp2):
        IF c(pc) THEN
	   sigma(vp1,c)
	ELSE
	   sigma(vp2,c)
	ENDIF
    ENDCASES
    MEASURE vp by <<

  hatAlpha(vm:AnnotativeModel): RECURSIVE AnnotativeExpression =
    CASES vm OF
      ModelBase(m): BaseExpression(alpha(m)),
      ModelChoice(pc, vm1, vm2): ChoiceExpression( pc, hatAlpha(vm1), hatAlpha(vm2) )
    ENDCASES
    MEASURE vm by <<

  conf: VAR Conf
  vModel, am : VAR AnnotativeModel
  l : VAR list[AnnotativeModel]
  commutative_product_family_product: THEOREM sigma(hatAlpha(vModel),conf) = alpha(pi(vModel,conf))

  %% COMPOSITIONAL

  partialModelComposition: [AnnotativeModel, AnnotativeModel -> AnnotativeModel]
  partialExpComposition: [AnnotativeExpression, AnnotativeExpression -> AnnotativeExpression]

  m1, m2 : VAR AnnotativeModel
  n : VAR nat

  isomorphismModelExp: AXIOM hatAlpha(partialModelComposition(m1,m2)) = partialExpComposition(hatAlpha(m1),hatAlpha(m2))



  IMPORTING CompositionalThings[nat]
  CompositionalModel : TYPE  = CompositionalThing[AnnotativeModel]
  cModel,cm : VAR CompositionalModel
  Pair : TYPE =  [# pc : PresenceCondition, idt : nat #]

%% dependents - receber ID, retornar lista de pares (PresenceCondition, Id)

%%%%%%%
%  CompositionalThing[AnnotativeModel] : TYPE =
%      [# idt : finite_sets[nat].finite_set,
%         E : [nat->AnnotativeModel],
%	 ord : (orders[nat].well_founded?),
%	 top : (idt) #]

%CM A(top) B C-->D
%[ (presenceConditionB , CM B), (presenceConditionC , CM C) ]

%CM A --> CM B C (idt - A) 

%%%%%%%

%  dependentIds(cm:CompositionalModel, id : { n:nat | member(n,cm`idt) } ) : finite_sets[nat].finite_set =
%    {n:nat | cm`ord(id,n)}
  
  getPC(am) : PresenceCondition =
    CASES am OF
      ModelBase(m): truepc,
      ModelChoice(pc, vm1, vm2): pc
    ENDCASES

  getPCi(cm:CompositionalModel, id : { n:nat | member(n,cm`idt) }) : PresenceCondition =
    getPC(cm`E(id))

  dependentes(cm:CompositionalModel, id : { n:nat | member(n,cm`idt) } ) : finite_sets[Pair].finite_set =
    {p: Pair | EXISTS (pc:PresenceCondition, n:nat) : cm`ord(id,n) AND p`idt=n AND p`pc = getPCi(cm,n)}

  set2list(s: finite_sets[Pair].finite_set) : RECURSIVE {l:list[Pair] | length(l) = card(s) AND 
				           FORALL(x:Pair): s(x) IFF member(x,l)} =
    IF empty?(s) THEN null
    ELSE cons( choose(s) , set2list(rest(s)) ) ENDIF
  MEASURE card(s)

  dependents(cm:CompositionalModel, id : { n:nat | member(n,cm`idt) } ) : list[Pair] =
    set2list(dependentes(cm,id))

%  foldls(f:[AnnotativeModel, AnnotativeModel -> AnnotativeModel], am:AnnotativeModel, s:finite_sets[AnnotativeModel].finite_set) :
%    RECURSIVE AnnotativeModel =
%    IF empty?(s) THEN am ELSE foldls(f, f(am, x), remove(x,s)) ENDIF  WHERE x = choose(s)
%    MEASURE card(s)

% fold[](f:[T, T -> T], elm:T, l:list[T]) : RECURSIVE T =
%    CASES l OF
%      null: elm,
%      cons(x, xs): fold(f, f(elm,x), xs)
%    ENDCASES
%    MEASURE length(l)

  foldl(f:[AnnotativeModel, AnnotativeModel -> AnnotativeModel], am:AnnotativeModel, l:list[AnnotativeModel]) : RECURSIVE AnnotativeModel =
    CASES l OF
      null: am,
      cons(x, xs): foldl(f, f(am,x), xs)
    ENDCASES
    MEASURE length(l)

  pi_r(cm:CompositionalModel, idt:nat, c:Conf) : RECURSIVE Product =
    pi(
	foldl(
	      partialModelComposition,
	      cm`E(idt),
	      map(LAMBDA(p:Pair):IF ( c(p`pc) ) THEN ModelBase(pi_r(cm, p`idt, c)) ELSE ModelBase(emptyproduct) ENDIF,
	          dependents(cm, idt)
	      )
	),
        c
    )
    MEASURE top(cm) BY ord(cm)

  pi_(cm:CompositionalModel, c:Conf) : Product =
    pi_r(cm, cm`top, c)

  CompositionalExpression : TYPE  = CompositionalThing[AnnotativeExpression]
  cExp,ce : VAR CompositionalExpression

  getPC(ae:AnnotativeExpression) : PresenceCondition =
    CASES ae OF
      BaseExpression(p): truepc,
      ChoiceExpression(pc, vm1, vm2): pc
    ENDCASES

  getPCi(ce:CompositionalExpression, id : { n:nat | member(n,ce`idt) }) : PresenceCondition =
    getPC(ce`E(id))

  dependentesExp(ce:CompositionalExpression, id : { n:nat | member(n,ce`idt) } ) : finite_sets[Pair].finite_set =
    {p: Pair | EXISTS (pc:PresenceCondition, n:nat) : ce`ord(id,n) AND p`idt=n AND p`pc = getPCi(ce,n)}

  dependentsExp(ce:CompositionalExpression, id : { n:nat | member(n,ce`idt) } ) : list[Pair] =
    set2list(dependentesExp(ce,id))

  foldlExp(f:[AnnotativeExpression, AnnotativeExpression -> AnnotativeExpression], ae:AnnotativeExpression, l:list[AnnotativeExpression]) : RECURSIVE AnnotativeExpression =
    CASES l OF
      null: ae,
      cons(x, xs): foldlExp(f, f(ae,x), xs)
    ENDCASES
    MEASURE length(l)

  sigma_r(ce:CompositionalExpression, idt:nat, c:Conf) : RECURSIVE Property =
    sigma(
	foldlExp(
	      partialExpComposition,
	      ce`E(idt),
	      map(LAMBDA(p:Pair):IF ( c(p`pc) ) THEN BaseExpression(sigma_r(ce, p`idt, c)) ELSE BaseExpression(emptyproperty) ENDIF,
	          dependentsExp(ce, idt)
	      )
	),
        c
    )
    MEASURE top(ce) BY ord(ce)

  sigma_(ce:CompositionalExpression, c:Conf) : Property =
    sigma_r(ce, ce`top, c)


  IMPORTING CompositionalFunctor[nat,AnnotativeModel,AnnotativeExpression]
  analyzeCM(cm) : CompositionalExpression = fmap(hatAlpha,cm)

  getPCequal: LEMMA getPC(cm`E(n)) = getPC(hatAlpha(E(cm)(n)))

  topEqual : LEMMA cm`top = fmap(hatAlpha, cm)`top

  dependentesEqual: LEMMA dependentes(cm, cm`top) = dependentesExp(fmap(hatAlpha, cm), fmap(hatAlpha, cm)`top)

  dependentsEqual: LEMMA dependents(cm, cm`top) = dependentsExp(fmap(hatAlpha, cm), fmap(hatAlpha, cm)`top)

  isomorphismModelExpList: AXIOM foldlExp(partialExpComposition, hatAlpha(am), map(hatAlpha,l)) = hatAlpha(foldl(partialModelComposition, am, l))

  commutative_feature_product_product: THEOREM sigma_(analyzeCM(cModel), conf) = alpha(pi_(cModel, conf))





  %% FAMILY - ANNOTATIVE

  PropertyADD : TYPE+
  toADD : [Property -> PropertyADD]

  LiftedAnnotativeExpression : DATATYPE
  BEGIN
     LiftedBaseExpression(p:PropertyADD): LiftedBaseExpression?
     LiftedChoiceExpression(pc:PresenceCondition, ae1:LiftedAnnotativeExpression, ae2:LiftedAnnotativeExpression): LiftedChoiceExpression?
  END LiftedAnnotativeExpression

  lift(ae:AnnotativeExpression): RECURSIVE LiftedAnnotativeExpression =
    CASES ae OF
      BaseExpression(p): LiftedBaseExpression(toADD(p)),
      ChoiceExpression(pc, ae1, ae2): LiftedChoiceExpression(pc, lift(ae1), lift(ae2))
    ENDCASES
    MEASURE ae by <<

  sigmaLift(vp:LiftedAnnotativeExpression,c:Conf): RECURSIVE PropertyADD =
    CASES vp OF
      LiftedBaseExpression(p): p,
      LiftedChoiceExpression(pc, vp1, vp2):
        IF c(pc) THEN
	   sigmaLift(vp1,c)
	ELSE
	   sigmaLift(vp2,c)
	ENDIF
    ENDCASES
    MEASURE vp by <<

    %commutative_family_product: THEOREM sigmaLift( lift(hatAlpha(vModel)), conf) = alpha(pi(vModel,conf))


END SPLTheory
