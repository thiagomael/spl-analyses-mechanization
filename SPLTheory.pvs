SPLTheory : THEORY
BEGIN

  Product : TYPE+
  Property: TYPE+

  alpha: [Product -> Property]

  PresenceCondition: TYPE+
  Conf: TYPE = set[PresenceCondition]

  AnnotativeModel : DATATYPE
  BEGIN
     ModelBase(m:Product): ModelBase?
     ModelChoice(pc:PresenceCondition, vm1:AnnotativeModel, vm2:AnnotativeModel): ModelChoice?
  END AnnotativeModel

  pi(vm:AnnotativeModel,c:Conf): RECURSIVE Product =
    CASES vm OF
      ModelBase(m): m,
      ModelChoice(pc, vm1, vm2):
        IF c(pc) THEN
	   pi(vm1,c)
	ELSE
	   pi(vm2,c)
	ENDIF
    ENDCASES
    MEASURE vm by <<

  AnnotativeExpression : DATATYPE
  BEGIN
     BaseExpression(p:Property): BaseExpression?
     ChoiceExpression(pc:PresenceCondition, vp1:AnnotativeExpression, vp2:AnnotativeExpression): ChoiceExpression?
  END AnnotativeExpression  

  sigma(vp:AnnotativeExpression,c:Conf): RECURSIVE Property =
    CASES vp OF
      BaseExpression(p): p,
      ChoiceExpression(pc, vp1, vp2):
        IF c(pc) THEN
	   sigma(vp1,c)
	ELSE
	   sigma(vp2,c)
	ENDIF
    ENDCASES
    MEASURE vp by <<

  hatAlpha(vm:AnnotativeModel): RECURSIVE AnnotativeExpression =
    CASES vm OF
      ModelBase(m): BaseExpression(alpha(m)),
      ModelChoice(pc, vm1, vm2): ChoiceExpression( pc, hatAlpha(vm1), hatAlpha(vm2) )
    ENDCASES
    MEASURE vm by <<

  conf: VAR Conf
  vModel : VAR AnnotativeModel
  commutative_product_family_product: THEOREM sigma(hatAlpha(vModel),conf) = alpha(pi(vModel,conf))

  partialModelComposition: [AnnotativeModel, AnnotativeModel -> AnnotativeModel]
  partialExpComposition: [AnnotativeExpression, AnnotativeExpression -> AnnotativeExpression]

  m1, m2 : VAR AnnotativeModel

  isomorphismModelExp: AXIOM hatAlpha(partialModelComposition(m1,m2)) = partialExpComposition(hatAlpha(m1),hatAlpha(m2))




END SPLTheory
