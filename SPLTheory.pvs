SPLTheory : THEORY
BEGIN

  Product : TYPE+
  emptyproduct : Product
  nonemptyproduct?(p:Product) : bool = p /= emptyproduct

  Property: TYPE+
  emptyproperty : Property
  nonemptyproperty?(p:Property) : bool = p /= emptyproperty

  alpha: [Product -> Property]

  PresenceCondition: TYPE+
  Conf: TYPE = set[PresenceCondition]

  AnnotativeModel : DATATYPE
  BEGIN
     ModelBase(m:Product): ModelBase?
     ModelChoice(pc:PresenceCondition, vm1:AnnotativeModel, vm2:AnnotativeModel): ModelChoice?
  END AnnotativeModel

  pi(vm:AnnotativeModel,c:Conf): RECURSIVE Product =
    CASES vm OF
      ModelBase(m): m,
      ModelChoice(pc, vm1, vm2):
        IF c(pc) THEN
	   pi(vm1,c)
	ELSE
	   pi(vm2,c)
	ENDIF
    ENDCASES
    MEASURE vm by <<

  AnnotativeExpression : DATATYPE
  BEGIN
     BaseExpression(p:Property): BaseExpression?
     ChoiceExpression(pc:PresenceCondition, vp1:AnnotativeExpression, vp2:AnnotativeExpression): ChoiceExpression?
  END AnnotativeExpression  

  sigma(vp:AnnotativeExpression,c:Conf): RECURSIVE Property =
    CASES vp OF
      BaseExpression(p): p,
      ChoiceExpression(pc, vp1, vp2):
        IF c(pc) THEN
	   sigma(vp1,c)
	ELSE
	   sigma(vp2,c)
	ENDIF
    ENDCASES
    MEASURE vp by <<

  hatAlpha(vm:AnnotativeModel): RECURSIVE AnnotativeExpression =
    CASES vm OF
      ModelBase(m): BaseExpression(alpha(m)),
      ModelChoice(pc, vm1, vm2): ChoiceExpression( pc, hatAlpha(vm1), hatAlpha(vm2) )
    ENDCASES
    MEASURE vm by <<

  conf: VAR Conf
  vModel : VAR AnnotativeModel
  commutative_product_family_product: THEOREM sigma(hatAlpha(vModel),conf) = alpha(pi(vModel,conf))

  %% COMPOSITIONAL

  partialModelComposition: [AnnotativeModel, AnnotativeModel -> AnnotativeModel]
  partialExpComposition: [AnnotativeExpression, AnnotativeExpression -> AnnotativeExpression]

  m1, m2 : VAR AnnotativeModel

  isomorphismModelExp: AXIOM hatAlpha(partialModelComposition(m1,m2)) = partialExpComposition(hatAlpha(m1),hatAlpha(m2))

  IMPORTING CompositionalThings[nat]
  CompositionalModel : TYPE  = CompositionalThing[AnnotativeModel]
  cModel,cm : VAR CompositionalModel

  top(cm) : {m: AnnotativeModel | EXISTS (n:nat) : ( E(cm)(n) = m AND NOT(EXISTS(j:nat): ord(cm)(j, n) ) ) }
  Pair : TYPE =  [# pc : PresenceCondition, cm : CompositionalModel #]
  dependents : [CompositionalModel, AnnotativeModel -> list[Pair]]
  
  foldl(f:[AnnotativeModel, AnnotativeModel -> AnnotativeModel], am:AnnotativeModel, l:list[AnnotativeModel]) : RECURSIVE AnnotativeModel =
    CASES l OF
      null: am,
      cons(x, xs): foldl(f, f(am,x), xs)
    ENDCASES
    MEASURE length(l)

  pi_(cm:CompositionalModel, c:Conf) : RECURSIVE Product =
    pi(
	foldl(
	      partialModelComposition,
	      top(cm),
	      map(LAMBDA(p:Pair):IF ( c(pc(p)) ) THEN ModelBase(pi_(cm(p),c)) ELSE ModelBase(emptyproduct) ENDIF, dependents(cm, top(cm)))
	),
        c
    )
    MEASURE length(dependents(cm, top(cm)))
    %MEASURE cm BY ord(cm)

  CompositionalExpression : TYPE  = CompositionalThing[AnnotativeExpression]
  cExp,ce : VAR CompositionalExpression

  topExp(ce) : {m: AnnotativeExpression | EXISTS (n:nat) : ( E(ce)(n) = m AND NOT(EXISTS(j:nat): ord(ce)(j, n) ) ) }
  PairExp : TYPE =  [# pc : PresenceCondition, ce : CompositionalExpression #]
  dependentsExp : [CompositionalExpression, AnnotativeExpression -> list[PairExp]]
  foldlExp(f:[AnnotativeExpression, AnnotativeExpression -> AnnotativeExpression], ae:AnnotativeExpression, l:list[AnnotativeExpression]) : RECURSIVE AnnotativeExpression =
    CASES l OF
      null: ae,
      cons(x, xs): foldlExp(f, f(ae,x), xs)
    ENDCASES
    MEASURE length(l)

  sigma_(ce:CompositionalExpression, c:Conf) : RECURSIVE Property =
    sigma(
	foldlExp(
	      partialExpComposition,
	      topExp(ce),
	      map(LAMBDA(p:PairExp):IF ( c(pc(p)) ) THEN BaseExpression(sigma_(ce(p),c)) ELSE BaseExpression(emptyproperty) ENDIF, dependentsExp(ce, topExp(ce)))
	),
        c
    )
    MEASURE length(dependentsExp(ce, topExp(ce)))

  IMPORTING CompositionalFunctor[nat,AnnotativeModel,AnnotativeExpression]

  analyzeCM(cm) : CompositionalExpression = fmap(hatAlpha,cm)
  commutative_feature_product_product: THEOREM sigma_(analyzeCM(cModel), conf) = alpha(pi_(cModel, conf))

  %% FAMILY - ANNOTATIVE

  PropertyADD : TYPE+
  toADD : [Property -> PropertyADD]

  LiftedAnnotativeExpression : DATATYPE
  BEGIN
     LiftedBaseExpression(p:PropertyADD): LiftedBaseExpression?
     LiftedChoiceExpression(pc:PresenceCondition, ae1:LiftedAnnotativeExpression, ae2:LiftedAnnotativeExpression): LiftedChoiceExpression?
  END LiftedAnnotativeExpression

  lift(ae:AnnotativeExpression): RECURSIVE LiftedAnnotativeExpression =
    CASES ae OF
      BaseExpression(p): LiftedBaseExpression(toADD(p)),
      ChoiceExpression(pc, ae1, ae2): LiftedChoiceExpression(pc, lift(ae1), lift(ae2))
    ENDCASES
    MEASURE ae by <<

  sigmaLift(vp:LiftedAnnotativeExpression,c:Conf): RECURSIVE PropertyADD =
    CASES vp OF
      LiftedBaseExpression(p): p,
      LiftedChoiceExpression(pc, vp1, vp2):
        IF c(pc) THEN
	   sigmaLift(vp1,c)
	ELSE
	   sigmaLift(vp2,c)
	ENDIF
    ENDCASES
    MEASURE vp by <<

    %commutative_family_product: THEOREM sigmaLift( lift(hatAlpha(vModel)), conf) = alpha(pi(vModel,conf))


END SPLTheory
