SPLTheory : THEORY
BEGIN

  Product : TYPE+
  Property: TYPE+

  alpha: [Product -> Property]

  PresenceCondition: TYPE+
  Conf: TYPE = set[PresenceCondition]

  AnnotativeModel : DATATYPE
  BEGIN
     ModelBase(m:Product): ModelBase?
     ModelChoice(pc:PresenceCondition, vm1:AnnotativeModel, vm2:AnnotativeModel): ModelChoice?
  END AnnotativeModel

  pi(vm:AnnotativeModel,c:Conf): RECURSIVE Product =
    CASES vm OF
      ModelBase(m): m,
      ModelChoice(pc, vm1, vm2):
        IF c(pc) THEN
	   pi(vm1,c)
	ELSE
	   pi(vm2,c)
	ENDIF
    ENDCASES
    MEASURE vm by <<

  AnnotativeExpression : DATATYPE
  BEGIN
     BaseExpression(p:Property): BaseExpression?
     ChoiceExpression(pc:PresenceCondition, vp1:AnnotativeExpression, vp2:AnnotativeExpression): ChoiceExpression?
  END AnnotativeExpression  

  sigma(vp:AnnotativeExpression,c:Conf): RECURSIVE Property =
    CASES vp OF
      BaseExpression(p): p,
      ChoiceExpression(pc, vp1, vp2):
        IF c(pc) THEN
	   sigma(vp1,c)
	ELSE
	   sigma(vp2,c)
	ENDIF
    ENDCASES
    MEASURE vp by <<

  hatAlpha(vm:AnnotativeModel): RECURSIVE AnnotativeExpression =
    CASES vm OF
      ModelBase(m): BaseExpression(alpha(m)),
      ModelChoice(pc, vm1, vm2): ChoiceExpression( pc, hatAlpha(vm1), hatAlpha(vm2) )
    ENDCASES
    MEASURE vm by <<

  conf: VAR Conf
  vModel : VAR AnnotativeModel
  commutative_product_family_product: THEOREM sigma(hatAlpha(vModel),conf) = alpha(pi(vModel,conf))

  partialModelComposition: [AnnotativeModel, AnnotativeModel -> AnnotativeModel]
  partialExpComposition: [AnnotativeExpression, AnnotativeExpression -> AnnotativeExpression]

  m1, m2 : VAR AnnotativeModel

  isomorphismModelExp: AXIOM hatAlpha(partialModelComposition(m1,m2)) = partialExpComposition(hatAlpha(m1),hatAlpha(m2))

  CompositionalModel : TYPE+
  CompositionalExpression : TYPE+
  top : [CompositionalModel -> AnnotativeModel]

  Pair : TYPE =  [# pc : PresenceCondition, cm : CompositionalModel #]
  Deps : TYPE = list[Pair]

  dependents : [CompositionalModel, AnnotativeModel -> Deps]

  pi_ : [Conf, CompositionalModel -> Product]

  analyzeCM : [CompositionalModel -> CompositionalExpression]

  sigma_ : [Conf, CompositionalExpression -> Property]

  cModel : VAR CompositionalModel
  commutative_feature_product_product: THEOREM sigma_(conf, analyzeCM(cModel)) = alpha(pi_(conf, cModel))

END SPLTheory
