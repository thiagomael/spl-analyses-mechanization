SPLTheory : THEORY
BEGIN

  Product : TYPE+
  emptyproduct : Product
  nonemptyproduct?(p:Product) : bool = p /= emptyproduct

  Property: TYPE+
  emptyproperty : Property
  nonemptyproperty?(p:Property) : bool = p /= emptyproperty

  alpha: [Product -> Property]

  PresenceCondition: TYPE+
  truepc : PresenceCondition
  Conf: TYPE = set[PresenceCondition]

  AnnotativeModel : DATATYPE
  BEGIN
     ModelBase(m:Product): ModelBase?
     ModelChoice(pc:PresenceCondition, vm1:AnnotativeModel, vm2:AnnotativeModel): ModelChoice?
  END AnnotativeModel

  pi(vm:AnnotativeModel,c:Conf): RECURSIVE Product =
    CASES vm OF
      ModelBase(m): m,
      ModelChoice(pc, vm1, vm2):
        IF c(pc) THEN
	   pi(vm1,c)
	ELSE
	   pi(vm2,c)
	ENDIF
    ENDCASES
    MEASURE vm by <<

  AnnotativeExpression : DATATYPE
  BEGIN
     BaseExpression(p:Property): BaseExpression?
     ChoiceExpression(pc:PresenceCondition, vp1:AnnotativeExpression, vp2:AnnotativeExpression): ChoiceExpression?
  END AnnotativeExpression  

  sigma(vp:AnnotativeExpression,c:Conf): RECURSIVE Property =
    CASES vp OF
      BaseExpression(p): p,
      ChoiceExpression(pc, vp1, vp2):
        IF c(pc) THEN
	   sigma(vp1,c)
	ELSE
	   sigma(vp2,c)
	ENDIF
    ENDCASES
    MEASURE vp by <<

  hatAlpha(vm:AnnotativeModel): RECURSIVE AnnotativeExpression =
    CASES vm OF
      ModelBase(m): BaseExpression(alpha(m)),
      ModelChoice(pc, vm1, vm2): ChoiceExpression( pc, hatAlpha(vm1), hatAlpha(vm2) )
    ENDCASES
    MEASURE vm by <<

  conf: VAR Conf
  vModel, am : VAR AnnotativeModel
  commutative_product_family_product: THEOREM sigma(hatAlpha(vModel),conf) = alpha(pi(vModel,conf))

  %% COMPOSITIONAL

  partialModelComposition: [AnnotativeModel, AnnotativeModel -> AnnotativeModel]
  partialExpComposition: [AnnotativeExpression, AnnotativeExpression -> AnnotativeExpression]

  m1, m2 : VAR AnnotativeModel
  n : VAR nat

  isomorphismModelExp: AXIOM hatAlpha(partialModelComposition(m1,m2)) = partialExpComposition(hatAlpha(m1),hatAlpha(m2))

  IMPORTING CompositionalThings[nat]
  CompositionalModel : TYPE  = CompositionalThing[AnnotativeModel]
  cModel,cm : VAR CompositionalModel

  Pair : TYPE =  [# pc : PresenceCondition, idt : nat #]
  dependents : [CompositionalModel, nat -> list[Pair]]

%% dependents - receber ID, retornar lista de pares (PresenceCondition, Id)

%%%%%%%
%  CompositionalThing[AnnotativeModel] : TYPE =
%      [# idt : finite_sets[nat].finite_set,
%         E : [nat->AnnotativeModel],
%	 ord : (orders[nat].well_founded?),
%	 top : (idt) #]

%CM A(top) B C-->D
%[ (presenceConditionB , CM B), (presenceConditionC , CM C) ]

%CM A --> CM B C (idt - A) 

%%%%%%%

  dependentIds(cm:CompositionalModel, id : { n:nat | member(n,cm`idt) } ) : finite_sets[nat].finite_set =
    {n:nat | cm`ord(id,n)}
  
  getPC(am) : PresenceCondition =
    CASES am OF
      ModelBase(m): truepc,
      ModelChoice(pc, vm1, vm2): pc
    ENDCASES

  getPCi(cm:CompositionalModel, id : { n:nat | member(n,cm`idt) }) : PresenceCondition =
    getPC(cm`E(id))

  dependentes(cm:CompositionalModel, id : { n:nat | member(n,cm`idt) } ) : finite_sets[Pair].finite_set =
    {p: Pair | EXISTS (pc:PresenceCondition, n:nat) : cm`ord(id,n) AND p`pc = getPCi(cm,n)}

  foldls(f:[AnnotativeModel, AnnotativeModel -> AnnotativeModel], am:AnnotativeModel, s:finite_sets[AnnotativeModel].finite_set) : RECURSIVE AnnotativeModel =
    IF empty?(s) THEN am ELSE foldls(f, f(am, x), remove(x,s)) ENDIF  WHERE x = choose(s)
    MEASURE card(s)




  foldl(f:[AnnotativeModel, AnnotativeModel -> AnnotativeModel], am:AnnotativeModel, l:list[AnnotativeModel]) : RECURSIVE AnnotativeModel =
    CASES l OF
      null: am,
      cons(x, xs): foldl(f, f(am,x), xs)
    ENDCASES
    MEASURE length(l)

  pi_r(cm:CompositionalModel, idt:nat, c:Conf) : RECURSIVE Product =
    pi(
	foldl(
	      partialModelComposition,
	      cm`E(cm`top),
	      map(LAMBDA(p:Pair):IF ( c(p`pc) ) THEN ModelBase(pi_r(cm, p`idt, c)) ELSE ModelBase(emptyproduct) ENDIF,
	          dependents(cm, idt)
	      )
	),
        c
    )
    MEASURE top(cm) BY ord(cm)

  pi_(cm:CompositionalModel, c:Conf) : Product =
    pi_r(cm, cm`top, c)

  CompositionalExpression : TYPE  = CompositionalThing[AnnotativeExpression]
  cExp,ce : VAR CompositionalExpression

  topExp(ce) : {m: AnnotativeExpression | EXISTS (n:nat) : ( E(ce)(n) = m AND NOT(EXISTS(j:nat): ord(ce)(j, n) ) ) }
  PairExp : TYPE =  [# pc : PresenceCondition, ce : CompositionalExpression #]
  dependentsExp : [CompositionalExpression, AnnotativeExpression -> list[PairExp]]
  foldlExp(f:[AnnotativeExpression, AnnotativeExpression -> AnnotativeExpression], ae:AnnotativeExpression, l:list[AnnotativeExpression]) : RECURSIVE AnnotativeExpression =
    CASES l OF
      null: ae,
      cons(x, xs): foldlExp(f, f(ae,x), xs)
    ENDCASES
    MEASURE length(l)

  sigma_(ce:CompositionalExpression, c:Conf) : RECURSIVE Property =
    sigma(
	foldlExp(
	      partialExpComposition,
	      topExp(ce),
	      map(LAMBDA(p:PairExp):IF ( c(pc(p)) ) THEN BaseExpression(sigma_(ce(p),c)) ELSE BaseExpression(emptyproperty) ENDIF, dependentsExp(ce, topExp(ce)))
	),
        c
    )
    MEASURE length(dependentsExp(ce, topExp(ce)))

  IMPORTING CompositionalFunctor[nat,AnnotativeModel,AnnotativeExpression]
  analyzeCM(cm) : CompositionalExpression = fmap(hatAlpha,cm)
  
  commutative_feature_product_product: THEOREM sigma_(analyzeCM(cModel), conf) = alpha(pi_(cModel, conf))

  %% FAMILY - ANNOTATIVE

  PropertyADD : TYPE+
  toADD : [Property -> PropertyADD]

  LiftedAnnotativeExpression : DATATYPE
  BEGIN
     LiftedBaseExpression(p:PropertyADD): LiftedBaseExpression?
     LiftedChoiceExpression(pc:PresenceCondition, ae1:LiftedAnnotativeExpression, ae2:LiftedAnnotativeExpression): LiftedChoiceExpression?
  END LiftedAnnotativeExpression

  lift(ae:AnnotativeExpression): RECURSIVE LiftedAnnotativeExpression =
    CASES ae OF
      BaseExpression(p): LiftedBaseExpression(toADD(p)),
      ChoiceExpression(pc, ae1, ae2): LiftedChoiceExpression(pc, lift(ae1), lift(ae2))
    ENDCASES
    MEASURE ae by <<

  sigmaLift(vp:LiftedAnnotativeExpression,c:Conf): RECURSIVE PropertyADD =
    CASES vp OF
      LiftedBaseExpression(p): p,
      LiftedChoiceExpression(pc, vp1, vp2):
        IF c(pc) THEN
	   sigmaLift(vp1,c)
	ELSE
	   sigmaLift(vp2,c)
	ENDIF
    ENDCASES
    MEASURE vp by <<

    %commutative_family_product: THEOREM sigmaLift( lift(hatAlpha(vModel)), conf) = alpha(pi(vModel,conf))


END SPLTheory
