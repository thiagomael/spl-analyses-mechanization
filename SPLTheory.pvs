SPLTheory : THEORY
BEGIN

  Product : DATATYPE
  BEGIN
     basic: basic?
     composite (m1,m2: Product): composite?
  END Product

  Property: TYPE+ FROM [bool+real]
  p_bottom: Property

  AnalyzeModelCompositeShell: TYPE = [Property, Property -> Property]
  analyzeModelCompositeShell: AnalyzeModelCompositeShell

  alpha(m: Product) : RECURSIVE Property =
    CASES m OF
       basic: p_bottom,
       composite(m1, m2): analyzeModelCompositeShell(alpha(m1), alpha(m2))
    ENDCASES
    MEASURE m by <<

  PresenceCondition: TYPE+
  Conf: TYPE = set[PresenceCondition]

  AnnotativeModel : DATATYPE
  BEGIN
     ModelBase(m:Product): ModelBase?
     ModelChoice(pc:PresenceCondition, vm1:AnnotativeModel, vm2:AnnotativeModel): ModelChoice?
     ModelComposite (vm1,vm2: AnnotativeModel): ModelComposite?
  END AnnotativeModel

  pi(vm:AnnotativeModel,c:Conf): RECURSIVE Product =
    CASES vm OF
      ModelBase(m): m,
      ModelChoice(pc, vm1, vm2):
        IF c(pc) THEN
	   pi(vm1,c)
	ELSE
	   pi(vm2,c)
	ENDIF,
      ModelComposite(vm1, vm2):
	   composite(pi(vm1,c),pi(vm2,c))
    ENDCASES
    MEASURE vm by <<

  AnnotativeExpression : DATATYPE
  BEGIN
     BaseExpression(p:Property): BaseExpression?
     ChoiceExpression(pc:PresenceCondition, vp1:AnnotativeExpression, vp2:AnnotativeExpression): ChoiceExpression?
     CompositeExpression (analysisShell: AnalyzeModelCompositeShell, vp1:AnnotativeExpression, vp2:AnnotativeExpression): CompositeExpression?
  END AnnotativeExpression  

  sigma(vp:AnnotativeExpression,c:Conf): RECURSIVE Property =
    CASES vp OF
      BaseExpression(p): p,
      ChoiceExpression(pc, vp1, vp2):
        IF c(pc) THEN
	   sigma(vp1,c)
	ELSE
	   sigma(vp2,c)
	ENDIF,
      CompositeExpression(analysisShell, vp1, vp2): 
	   analysisShell(sigma(vp1,c), sigma(vp2,c))
    ENDCASES
    MEASURE vp by <<

  hatAlpha(vm:AnnotativeModel): RECURSIVE AnnotativeExpression =
    CASES vm OF
      ModelBase(m): BaseExpression(alpha(m)),
      ModelChoice(pc, vm1, vm2): ChoiceExpression( pc, hatAlpha(vm1), hatAlpha(vm2) ),
      ModelComposite(vm1, vm2): CompositeExpression(analyzeModelCompositeShell, hatAlpha(vm1), hatAlpha(vm2) )
    ENDCASES
    MEASURE vm by <<

  conf: VAR Conf
  vModel : VAR AnnotativeModel
  commutative_product_family_product: THEOREM sigma(hatAlpha(vModel),conf) = alpha(pi(vModel,conf))


END SPLTheory
