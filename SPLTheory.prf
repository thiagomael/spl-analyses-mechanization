(SPLTheory
 (pi_TCC1 0
  (pi_TCC1-1 nil 3734998866 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[AnnotativeModel])"
     SPLTheory nil))
   nil))
 (pi_TCC2 0
  (pi_TCC2-1 nil 3734998866 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[AnnotativeModel])"
     SPLTheory nil))
   nil))
 (sigma_TCC1 0
  (sigma_TCC1-1 nil 3734998866 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[AnnotativeExpression])"
     SPLTheory nil))
   nil))
 (sigma_TCC2 0
  (sigma_TCC2-1 nil 3734998866 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[AnnotativeExpression])"
     SPLTheory nil))
   nil))
 (hatAlpha_TCC1 0
  (hatAlpha_TCC1-1 nil 3734998866 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[AnnotativeModel])"
     SPLTheory nil))
   nil))
 (hatAlpha_TCC2 0
  (hatAlpha_TCC2-1 nil 3734998866 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[AnnotativeModel])"
     SPLTheory nil))
   nil))
 (commutative_product_family_product 0
  (commutative_product_family_product-1 nil 3734364247
   ("" (skolem 1 (c _))
    (("" (induct vModel)
      (("1" (skolem 1 base)
        (("1" (expand sigma)
          (("1" (assert)
            (("1" (expand hatAlpha)
              (("1" (expand pi) (("1" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (skolem 1 (pcon m1 m2))
        (("2" (flatten)
          (("2" (expand hatAlpha +)
            (("2" (expand pi +)
              (("2" (lift-if)
                (("2" (bddsimp)
                  (("1" (expand sigma 1) (("1" (assert) nil nil)) nil)
                   ("2" (assert)
                    (("2" (expand sigma 2) (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((AnnotativeModel type-decl nil SPLTheory nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Property nonempty-type-decl nil SPLTheory nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AnnotativeExpression type-decl nil SPLTheory nil)
    (PresenceCondition nonempty-type-decl nil SPLTheory nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Conf type-eq-decl nil SPLTheory nil)
    (sigma def-decl "Property" SPLTheory nil)
    (hatAlpha def-decl "AnnotativeExpression" SPLTheory nil)
    (Product nonempty-type-decl nil SPLTheory nil)
    (alpha const-decl "[Product -> Property]" SPLTheory nil)
    (pi def-decl "Product" SPLTheory nil)
    (AnnotativeModel_induction formula-decl nil SPLTheory nil))
   shostak))
 (dependentes_TCC1 0
  (dependentes_TCC1-1 nil 3768310294 ("" (subtype-tcc) nil nil) nil
   nil))
 (dependentes_TCC2 0
  (dependentes_TCC2-1 nil 3768310294 ("" (subtype-tcc) nil nil) nil
   nil))
 (set2list_TCC1 0
  (set2list_TCC1-1 nil 3769508394 ("" (subtype-tcc) nil nil) nil nil))
 (set2list_TCC2 0
  (set2list_TCC2-1 nil 3769508394 ("" (subtype-tcc) nil nil) nil nil))
 (set2list_TCC3 0
  (set2list_TCC3-1 nil 3769508394 ("" (termination-tcc) nil nil) nil
   nil))
 (set2list_TCC4 0
  (set2list_TCC4-1 nil 3769508394 ("" (subtype-tcc) nil nil) nil nil))
 (foldl_TCC1 0
  (foldl_TCC1-1 nil 3762261712 ("" (termination-tcc) nil nil) nil nil))
 (pi_r_TCC1 0
  (pi_r_TCC1-1 nil 3768310294 ("" (well-founded-tcc) nil nil) nil nil))
 (pi_r_TCC2 0
  (pi_r_TCC2-1 nil 3768310294 ("" (termination-tcc) nil nil) nil nil))
 (pi_r_TCC3 0
  (pi_r_TCC3-1 nil 3769508394 ("" (subtype-tcc) nil nil) nil nil))
 (dependentesExp_TCC1 0
  (dependentesExp_TCC1-1 nil 3769508394 ("" (subtype-tcc) nil nil) nil
   nil))
 (dependentesExp_TCC2 0
  (dependentesExp_TCC2-1 nil 3769508394 ("" (subtype-tcc) nil nil) nil
   nil))
 (foldlExp_TCC1 0
  (foldlExp_TCC1-1 nil 3762261712 ("" (termination-tcc) nil nil) nil
   nil))
 (sigma_r_TCC1 0
  (sigma_r_TCC1-1 nil 3769508394 ("" (well-founded-tcc) nil nil) nil
   nil))
 (sigma_r_TCC2 0
  (sigma_r_TCC2-1 nil 3769508394 ("" (termination-tcc) nil nil) nil
   nil))
 (sigma_r_TCC3 0
  (sigma_r_TCC3-1 nil 3769508394 ("" (subtype-tcc) nil nil) nil nil))
 (getPCequal 0
  (getPCequal-1 nil 3776680652
   ("" (skolem 1 (cm n))
    (("" (expand getPC)
      (("" (lift-if)
        (("" (bddsimp)
          (("1" (assert)
            (("1" (expand hatAlpha) (("1" (propax) nil nil)) nil)) nil)
           ("2" (expand hatAlpha) (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((hatAlpha def-decl "AnnotativeExpression" SPLTheory nil)) shostak))
 (topEqual 0
  (topEqual-1 nil 3776690283
   ("" (skolem 1 cm) (("" (expand fmap) (("" (propax) nil nil)) nil))
    nil)
   ((fmap const-decl "CompositionalThing[U]" CompositionalFunctor nil))
   shostak))
 (dependentesEqual_TCC1 0
  (dependentesEqual_TCC1-1 nil 3776764537 ("" (subtype-tcc) nil nil)
   nil nil))
 (dependentesEqual_TCC2 0
  (dependentesEqual_TCC2-1 nil 3776764537 ("" (subtype-tcc) nil nil)
   nil nil))
 (dependentesEqual 0
  (dependentesEqual-1 nil 3776764544
   ("" (skolem 1 cm)
    (("" (expand dependentes)
      (("" (expand dependentesExp)
        (("" (lemma topEqual)
          (("" (instantiate -1 cm)
            (("" (lemma getPCequal)
              (("" (instantiate -1 (cm "cm`top"))
                (("" (expand getPCi)
                  (("" (assert)
                    (("" (replace -2 1 RL)
                      (("" (decompose-equality 1)
                        (("" (bddsimp)
                          (("1" (skolem -1 (e n))
                            (("1" (flatten)
                              (("1"
                                (instantiate 1 (e n))
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand fmap 1)
                                    (("1"
                                      (replace -3)
                                      (("1"
                                        (expand hatAlpha 1)
                                        (("1"
                                          (expand getPC 1)
                                          (("1"
                                            (lift-if 1)
                                            (("1"
                                              (bddsimp)
                                              (("1" (assert) nil nil)
                                               ("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skolem -1 (e n))
                            (("2" (flatten)
                              (("2"
                                (instantiate 1 (e n))
                                (("2"
                                  (assert)
                                  (("2"
                                    (replace -3)
                                    (("2"
                                      (bddsimp)
                                      (("1"
                                        (expand getPC 1)
                                        (("1"
                                          (expand fmap 1)
                                          (("1"
                                            (expand hatAlpha 1)
                                            (("1"
                                              (lift-if 1)
                                              (("1"
                                                (bddsimp)
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand fmap -1)
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((dependentes const-decl "finite_sets[Pair].finite_set" SPLTheory
     nil)
    (topEqual formula-decl nil SPLTheory nil)
    (CompositionalModel type-eq-decl nil SPLTheory nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AnnotativeModel type-decl nil SPLTheory nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (getPCequal formula-decl nil SPLTheory nil)
    (getPCi const-decl "PresenceCondition" SPLTheory nil)
    (getPCi const-decl "PresenceCondition" SPLTheory nil)
    (PresenceCondition nonempty-type-decl nil SPLTheory nil)
    (Pair type-eq-decl nil SPLTheory nil)
    (getPC const-decl "PresenceCondition" SPLTheory nil)
    (hatAlpha def-decl "AnnotativeExpression" SPLTheory nil)
    (fmap const-decl "CompositionalThing[U]" CompositionalFunctor nil)
    (CompositionalThing type-eq-decl nil CompositionalThings nil)
    (AnnotativeExpression type-decl nil SPLTheory nil)
    (getPC const-decl "PresenceCondition" SPLTheory nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dependentesExp const-decl "finite_sets[Pair].finite_set" SPLTheory
     nil))
   shostak))
 (dependentsEqual 0
  (dependentsEqual-1 nil 3776680361
   ("" (expand dependents)
    (("" (expand dependentsExp)
      (("" (skolem 1 cm)
        (("" (use dependentesEqual) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((dependentsExp const-decl "list[Pair]" SPLTheory nil)
    (dependentesEqual formula-decl nil SPLTheory nil)
    (CompositionalModel type-eq-decl nil SPLTheory nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AnnotativeModel type-decl nil SPLTheory nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (dependents const-decl "list[Pair]" SPLTheory nil))
   shostak))
 (commutative_feature_product_product 0
  (commutative_feature_product_product-4 "" 3774361999
   ("" (skolem 1 (cm c))
    (("" (expand pi_)
      (("" (expand sigma_)
        (("" (expand sigma_r)
          (("" (expand pi_r)
            (("" (lemma "commutative_product_family_product")
              (("" (instantiate -1 (c _))
                ((""
                  (instantiate -1
                   "foldl(partialModelComposition, cm`E(cm`top),
                      map(LAMBDA (p: Pair):
                            IF (c(p`pc)) THEN ModelBase(pi_r(cm, p`idt, c))
                            ELSE ModelBase(emptyproduct)
                            ENDIF,
                          dependents(cm, cm`top)))")
                  (("" (replace -1 1 RL)
                    (("" (hide -1)
                      ((""
                        (case-replace "foldlExp(partialExpComposition,
                     analyzeCM(cm)`E(analyzeCM(cm)`top),
                     map(LAMBDA (p: Pair):
                           IF (c(p`pc))
                             THEN BaseExpression(sigma_r
                                                 (analyzeCM(cm), p`idt, c))
                           ELSE BaseExpression(emptyproperty)
                           ENDIF,
                         dependentsExp(analyzeCM(cm), analyzeCM(cm)`top)))=hatAlpha(foldl(partialModelComposition, cm`E(cm`top),
                            map(LAMBDA (p: Pair):
                                  IF (c(p`pc))
                                    THEN ModelBase(pi_r(cm, p`idt, c))
                                  ELSE ModelBase(emptyproduct)
                                  ENDIF,
                                dependents(cm, cm`top))))")
                        (("" (hide 2)
                          (("" (expand analyzeCM)
                            (("" (expand fmap 1 1)
                              ((""
                                (expand fmap 1 1)
                                ((""
                                  (lemma dependentsEqual)
                                  ((""
                                    (instantiate -1 cm)
                                    ((""
                                      (replace -1 1 RL)
                                      ((""
                                        (case
                                         "ModelBase?(E(cm)(top(cm)))")
                                        (("1"
                                          (expand hatAlpha 1 1)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (hide -2)
                                              (("1"
                                                (postpone)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand hatAlpha 2 1)
                                          (("2"
                                            (assert)
                                            (("2" (postpone) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (commutative_feature_product_product-3 "" 3773155207
   ("" (skolem 1 (cm conf))
    (("" (lemma "wf_induction[nat, cm`ord].wf_induction")
      (("" (expand pi_)
        (("" (expand pi_r)
          (("" (expand foldl)
            (("" (expand sigma_)
              (("" (expand sigma_r)
                (("" (expand foldlExp) (("" (postpone) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (commutative_feature_product_product-2 "measure_induction" 3763472700
   ("" (skolem 1 (cm conf))
    (("" (lemma "wf_induction[nat, cm`ord].wf_induction")
      (("" (expand sigma_)
        (("" (expand pi_)
          ((""
            (instantiate -1
             "LAMBDA(i:nat):cm`idt(i) IMPLIES sigma_r(analyzeCM(cm), i, conf) = alpha(pi_r(cm, i, conf))")
            (("" (split)
              (("1" (expand analyzeCM 1 2)
                (("1" (expand fmap 1)
                  (("1" (instantiate -1 "top(cm)")
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (skolem 1 x)
                  (("2" (flatten)
                    (("2"
                      (case "EXISTS(y:nat): cm`ord(y,x) AND cm`idt(y)")
                      (("1" (skolem -1 y)
                        (("1" (flatten)
                          (("1" (instantiate -3 y)
                            (("1" (assert)
                              (("1"
                                (expand sigma_r 1)
                                (("1"
                                  (expand pi_r 1)
                                  (("1"
                                    (expand dependents)
                                    (("1"
                                      (expand set2list)
                                      (("1"
                                        (case
                                         "empty?(dependentes(cm, x))")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (expand analyzeCM 1 4)
                                            (("1"
                                              (expand fmap 1)
                                              (("1"
                                                (expand dependentsExp)
                                                (("1"
                                                  (expand set2list)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (case
                                                       "empty?(dependentesExp((# idt := idt(cm),
                                                     E
                                                     := LAMBDA
                                                        (x: nat):
                                                        hatAlpha(E(cm)(x)),
                                                     ord := ord(cm),
                                                     top := top(cm) #),
                                                  x))")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (expand map)
                                                          (("1"
                                                            (expand
                                                             foldl)
                                                            (("1"
                                                              (expand
                                                               foldlExp)
                                                              (("1"
                                                                (expand
                                                                 analyzeCM
                                                                 1)
                                                                (("1"
                                                                  (expand
                                                                   fmap
                                                                   1)
                                                                  (("1"
                                                                    (use
                                                                     "commutative_product_family_product")
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (postpone)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (postpone) nil nil)
                                         ("3" (postpone) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (postpone) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (commutative_feature_product_product-1 nil 3762875081
   ("" (skolem 1 (cm c))
    (("" (expand pi_)
      (("" (expand foldl)
        ((""
          (case "map(LAMBDA (p: Pair):
                            IF (c(pc(p))) THEN ModelBase(pi_(cm(p), c))
                            ELSE ModelBase(emptyproduct)
                            ENDIF,
                          dependents(cm, top(cm)))=null")
          (("1" (assert) (("1" (postpone) nil nil)) nil)
           ("2" (lift-if)
            (("2" (bddsimp)
              (("2" (expand pi)
                (("2" (lift-if)
                  (("2" (bddsimp)
                    (("1" (postpone) nil nil) ("2" (postpone) nil nil)
                     ("3" (postpone) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (lift_TCC1 0
  (lift_TCC1-1 nil 3762261712 ("" (termination-tcc) nil nil) nil nil))
 (lift_TCC2 0
  (lift_TCC2-1 nil 3762261712 ("" (termination-tcc) nil nil) nil nil))
 (sigmaLift_TCC1 0
  (sigmaLift_TCC1-1 nil 3762261712 ("" (termination-tcc) nil nil) nil
   nil))
 (sigmaLift_TCC2 0
  (sigmaLift_TCC2-1 nil 3762261712 ("" (termination-tcc) nil nil) nil
   nil)))

